##########################################
#
# chime_outrigger_128.yaml
#
# Config to support the CHIME outriggers 128 elements (64 feeds) with OpenCL kernels.
#
# This configuration is not finalized.
#
# Set "enable_fake_data" to disable DPDK and instead generate fake data on the CPU
#
# Author: Andre Renard
#
##########################################
---
type: config
# Logging level can be one of:
# OFF, ERROR, WARN, INFO, DEBUG, DEBUG2 (case insensitive)
# Note DEBUG and DEBUG2 require a build with (-DCMAKE_BUILD_TYPE=Debug)
log_level: debug

buffer_depth: 12
baseband_buffer_depth: 12 # TODO increase this for the baseband buffer
samples_per_data_set: 32768 * 2
num_local_freq: 16
num_elements: 128
num_blocks: (num_elements / block_size) * (num_elements / block_size + 1) / 2
sizeof_int: 4
num_gpus: 2
block_size: 32
num_data_sets: 1
data_format: "dot4b"
# The number of FPGA links per NUMA domain
num_links: 16

cpu_affinity: [8, 9, 10, 11, 12, 13, 14, 15, 16, 32, 33, 34, 35, 36, 37, 38, 39]

# Pool
main_pool:
    kotekan_metadata_pool: chimeMetadata
    num_metadata_objects: 128 * buffer_depth

gpu_input_merged:
    num_frames: buffer_depth * 4
    frame_size: samples_per_data_set * num_elements * num_local_freq
    metadata_pool: main_pool
    gpu_input_merged_0:
        numa_node: 0
        kotekan_buffer: standard
    gpu_input_merged_1:
        numa_node: 1
        kotekan_buffer: standard

gpu_output_buffers:
    num_frames: buffer_depth
    frame_size: num_local_freq * num_blocks * (block_size*block_size)*2*num_data_sets  * sizeof_int
    metadata_pool: main_pool
    gpu_output_buffer_0:
        numa_node: 0
        kotekan_buffer: standard
    gpu_output_buffer_1:
        numa_node: 1
        kotekan_buffer: standard

gpu_input_buffers:
    num_frames: baseband_buffer_depth
    frame_size: samples_per_data_set * num_elements * num_local_freq
    metadata_pool: main_pool
{%- for id in range(16) %}
    gpu_input_buffer_{{ id }}:
        numa_node: 0
        kotekan_buffer: standard
{%- endfor %}
{%- for id in range(16,32) %}
    gpu_input_buffer_{{ id }}:
        numa_node: 1
        kotekan_buffer: standard
{%- endfor %}

lost_samples_buffers:
    num_frames: buffer_depth
    frame_size: samples_per_data_set
    metadata_pool: main_pool
{%- for id in range(16) %}
    lost_samples_buffer_{{ id }}:
        numa_node: 0
        kotekan_buffer: standard
{%- endfor %}
{%- for id in range(16,32) %}
    lost_samples_buffer_{{ id }}:
        numa_node: 1
        kotekan_buffer: standard
{%- endfor %}

# DPDK packet capture from FPGA
{% if enable_fake_data is not defined %}
dpdk:
    kotekan_stage: dpdkCore
    # Format is index = lcore, value = cpu core
    lcore_cpu_map: [0, 1, 2, 3, 4, 5, 6, 7, 24, 25, 26, 27, 28, 29, 30, 31]
    master_lcore_cpu: 9
    fpga_packet_size: 4160
    num_mem_channels: 8
    alignment: samples_per_data_set
    mbuf_cache_size: 250
    init_mem_alloc: 1024,1024
    # Format is index = lcore, value = array of port IDs
    # so [[0,1],[2,3]] maps lcore 0 to service ports 0 and 1,
    # and lcore 1 to service ports 2 and 3.
    lcore_port_map:
        - [0,1]
        - [2,3]
        - [4,5]
        - [6,7]
        - [8,9]
        - [10,11]
        - [12,13]
        - [14,15]
        - [16,17]
        - [18,19]
        - [20,21]
        - [22,23]
        - [24,25]
        - [26,27]
        - [28,29]
        - [30,31]

    # One handler must be given per port on the system.
    handlers:
{%- for id in range(32) %}
        - dpdk_handler: iceBoardStandard
          out_buf: gpu_input_buffer_{{ id }}
          lost_samples_buf: lost_samples_buffer_{{ id }}
{%- endfor %}

zero_samples:
{%- for id in range(32) %}
    zero_{{ id }}:
        kotekan_stage: zeroSamples
        out_buf: gpu_input_buffer_{{ id }}
        lost_samples_buf: lost_samples_buffer_{{ id }}
{%- endfor %}

buffer_merge_0:
    kotekan_stage: bufferMerge
    in_bufs:
{%- for id in range(16) %}
        - gpu_input_buffer_{{ id }}
{%- endfor %}
    out_buf: gpu_input_merged_0

buffer_merge_1:
    kotekan_stage: bufferMerge
    in_bufs:
{%- for id in range(16,32) %}
        - gpu_input_buffer_{{ id }}
{%- endfor %}
    out_buf: gpu_input_merged_1
{% endif %}

# Use fake data instead of FPGA data
{% if enable_fake_data is defined %}
gen_data:
    type: const
    value: 153
    wait: true
    gen_data_0:
        kotekan_stage: testDataGen
        out_buf: gpu_input_merged_0
    gen_data_1:
        kotekan_stage: testDataGen
        out_buf: gpu_input_merged_1
{% endif %}

gpu:
    profiling: true
    log_profiling: true
    kernel_path: "../../lib/opencl/kernels/"
    gain_dir: "/etc/kotekan/"
    log_level: info
    frame_arrival_period: samples_per_data_set / 390625.0 / num_links
    commands: &command_list
        - name: clInputData
        - name: clOutputDataZero
        - name: clKVCorr
        - name: clOutputData
    gpu_0:
        kotekan_stage: clProcess
        cpu_affinity: [9, 10, 11, 12]
        gpu_id: 0
        commands: *command_list
        in_buffers:
            network_buf: gpu_input_merged_0
            # We add these buffers here to make sure the memory gets registered
{%- for id in range(16) %}
            in_buf_{{ id }}: gpu_input_buffer_{{ id }}
{%- endfor %}
        out_buffers:
            output_buf: gpu_output_buffer_0
    gpu_1:
        kotekan_stage: clProcess
        cpu_affinity: [42, 43, 44, 45]
        gpu_id: 1
        commands: *command_list
        in_buffers:
            network_buf: gpu_input_merged_1
            # We add these buffers here to make sure the memory gets registered
{%- for id in range(16,32) %}
            in_buf_{{ id }}: gpu_input_buffer_{{ id }}
{%- endfor %}
        out_buffers:
            output_buf: gpu_output_buffer_1
