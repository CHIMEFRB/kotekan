<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Downward Edges</title>
<style>


.node {
  fill: rgba(32, 202, 117, 0.452);
  /* stroke: #fff; */
  /* stroke-width: 1.5px; */
}

.link {
  fill: none;
  stroke: #000;
  stroke-width: 1.5px;
  opacity: 0.4;
  marker-end: url(#end-arrow);
}

.label {
  fill: rgb(0, 0, 0);
  font-family: sans-serif;
  font-size: 15;
}

</style>
</head>
<body>
    <a href="../index.html">cola.js home</a>
<h1>Kotekan Pipeline</h1>
<script src="{{url_for('static', filename='d3v4.js')}}"></script>
<script src="{{url_for('static', filename='cola.min.js')}}"></script>
<script type="text/javascript" src="https://canvasjs.com/assets/script/jquery-1.11.1.min.js"></script>
<script>
    var width = 960,
        height = 500;
  //var w = document.getElementById("graph").clientWidth;
  //var h = document.getElementById("graph").clientHeight;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var d3cola = cola.d3adaptor(d3)
        //.handleDisconnected(false)
        .linkDistance(80)
        //.groupCompactness(100)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom().on("zoom", function () {
            svg.attr("transform", d3.event.transform)
        }));

    // Replace "&#39;" chars as single quote "'"
    var rawData =  "{{data.json()}}".split('&#39;').join('"');
    // Add double quotes to None elements ('None') then parse json into javascript object
    var buffers = jQuery.parseJSON(rawData.split('None').join('"None"'));
    // Get buffer names
    var bufNames = Object.keys(buffers);
        
    console.log(buffers);

    d3.json("{{url_for('static', filename='chris.json')}}", function (error, graph) {
        var nodeRadius = 8;

        var nodes = [], links = [];
        for (var val of bufNames) {
          var obj = buffers[val];
          nodes.push({name: val});
          for (var stage in obj.producers) {
              nodes.push({name: stage});
              links.push({source: nodes.find(obj => obj.name === stage), target: nodes.find(obj => obj.name === val)});
          }

          if (obj.consumers !== "None") {
            for (var stage in obj.consumers) {
              nodes.push({name: stage});
              links.push({source: nodes.find(d => d.name === val), target: nodes.find(d => d.name === stage)});
            }
          }
        }
 
        // remove all duplicated nodes
        graph.nodes = Array.from(new Set(nodes.map(a => a.name)))
                      .map(name => {
                          return nodes.find(a => a.name === name)
                      });
        graph.links = links;

        console.log(graph.nodes)
        console.log(graph.links)

        d3cola
            .nodes(graph.nodes)
            .links(graph.links)
            .flowLayout("y", 60)
            // .symmetricDiffLinkLengths(6)
            //.convergenceThreshold(1e-9)
            .defaultNodeSize(100)
            .handleDisconnected(true)
            .avoidOverlaps(true)
            .start(30,20,20);

        // define arrow markers for graph links
        svg.append('svg:defs').append('svg:marker')
            .attr('id', 'end-arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 6)
            .attr('markerWidth', 3)
            .attr('markerHeight', 3)
            .attr('orient', 'auto')
            .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#000');

        var path = svg.selectAll(".link")
            .data(graph.links)
            .enter().append('line')
            .attr('class', 'link');

        var margin = 6, pad = 12, width = 60, height = 40;
        var node = svg.selectAll(".node")
            .data(graph.nodes)
            .enter().append("rect")
            .attr("class", "node")
            .attr("width", function (d) { return width + 2 * pad + 2 * margin; })
            .attr("height", function (d) { return height + 2 * pad + 2 * margin; })
            .attr("rx", 5).attr("ry", 5)
            .call(d3cola.drag);

        var label = svg.selectAll(".label")
            .data(graph.nodes)
            .enter().append("text")
            .attr("class", "label")
            .call(d3cola.drag);

        var insertLinebreaks = function (d) {
            var el = d3.select(this);
            var words = d.name.split('/');

            var tspan = el.append('tspan').text(words[0])
                          .attr('x', margin/2).attr('dy', '15')
                          .attr("font-size", "15");

            for (var i = 1; i < words.length; i++) {
                tspan = el.append('tspan').text('/' + words[i]);
                tspan.attr('x', margin/2).attr('dy', '15')
                     .attr("font-size", "15");
            }
        };

        label.each(insertLinebreaks);

        node.append("title")
            .text(function (d) { return d.name; });

        // Add utilization for all buffers and record their index
        var index = [];
        label._groups[0].reduce((pre, cur, ind) => {
            if (bufNames.includes(cur.textContent)) {
                var el = d3.select(cur);
                tspan = el.append('tspan')
                          .text(buffers[cur.textContent].num_full_frame + "/" + buffers[cur.textContent].num_frames)
                tspan.attr('x', margin/2).attr('dy', '15')
                     .attr("font-size", "15")
                     .attr("id", "utl");
                index.push(ind)
            }
        }, 0)

        // Update utilization
        function update_utl(new_buffers){
            console.log(new_buffers);
            for (var i of index) {
                var name = d3.select(label._groups[0][i]).select("tspan").text();
                d3.select(label._groups[0][i]).select("#utl")
                  .text(new_buffers[name].num_full_frame + "/" + new_buffers[name].num_frames);
            }
        }

        // Time between updating kotekan metrics
        const POLL_WAIT_TIME_MS = 1000;
        // Poll kotekan via web server every POLL_WAIT_TIME_MS and update page with new metrics
        async function poll() {
            let response = await fetch("/update");

            if (response.status == 502) {
                // Status 502 is a connection timeout error,
                // may happen when the connection was pending for too long,
                // and the remote server or a proxy closed it
                // let's reconnect
            } else if (response.status != 200) {
                // An error - let's show it
                console.log("Error: " + response.statusText);
                // Reconnect in one second
                await new Promise(resolve => setTimeout(resolve, 1000));
            } else {

                // Get and show the message
                let new_buffers = await response.json();
                update_utl(new_buffers);
            }
            // Call poll() again to get the next message
            setTimeout(() => { poll(); }, POLL_WAIT_TIME_MS);
        }
        // Start polling kotekan for metrics
        poll();

        d3cola.on("tick", function () {
            node.each(function (d) {
                d.innerBounds = d.bounds.inflate(- margin);
            });

            path.each(function (d) {
                d.route = cola.makeEdgeBetween(d.source.innerBounds, d.target.innerBounds, 5);
                if (isIE())  this.parentNode.insertBefore(this, this);
            });

            path.attr("x1", function (d) { return d.route.sourceIntersection.x; })
                .attr("y1", function (d) { return d.route.sourceIntersection.y; })
                .attr("x2", function (d) { return d.route.arrowStart.x; })
                .attr("y2", function (d) { return d.route.arrowStart.y; });

            label.each(function (d) {
                var b = this.getBBox();
                d.width = b.width + 2 * margin + 8;
                d.height = b.height + 2 * margin + 8;
            });

            node.attr("x", function (d) { return d.innerBounds.x; })
                .attr("y", function (d) { return d.innerBounds.y; })
                .attr("width", function (d) { return Math.abs(d.innerBounds.width()); })
                .attr("height", function (d) { return Math.abs(d.innerBounds.height()); });

            label.attr("transform", function (d) {
                return "translate(" + d.innerBounds.x + margin + "," + (d.innerBounds.y + margin/2) + ")";
            });
        });
        // turn on overlap avoidance after first convergence
        //cola.on("end", function () {
        //    if (!cola.avoidOverlaps()) {
        //        graph.nodes.forEach(function (v) {
        //            v.width = v.height = 10;
        //        });
        //        cola.avoidOverlaps(true);
        //        cola.start();
        //    }
        //});
    });

    function isIE() { return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') && (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null))); }
</script>

<!--p>Pairs of nodes connected by an edge have a vertical separation constraint, requiring that the source be a minimum distance above the target.
   We also require that node bounding boxes cannot overlap.
     The unconstrained layout of the same graph looks like <a href="unconstrained.html">this</a>.
    </p-->
    <!--p>Here's <a href="3dtree.html">a 3D version</a> of the same graph!</p-->
<!--script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63535113-1', 'auto');
  ga('send', 'pageview');

</script-->
</body>
</html>
