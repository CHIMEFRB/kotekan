<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Downward Edges</title>
<style>


.node {
  fill: rgba(32, 202, 117, 0.452);
}

.link {
  fill: none;
  stroke: #000;
  stroke-width: 1.5px;
  opacity: 0.4;
  marker-end: url(#end-arrow);
}

.label {
  fill: rgb(0, 0, 0);
  font-family: sans-serif;
  font-size: 15;
}

</style>
</head>
<body>
    <a href="../index.html">cola.js home</a>
<h1>Kotekan Pipeline</h1>
<script src="{{url_for('static', filename='d3v4.js')}}"></script>
<script src="{{url_for('static', filename='cola.min.js')}}"></script>
<script type="text/javascript" src="https://canvasjs.com/assets/script/jquery-1.11.1.min.js"></script>
<script>
    var width = 960, height = 500;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var d3cola = cola.d3adaptor(d3)
        .linkDistance(80)
        .size([width, height]);

    // Add a svg section and employ zooming
    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom().on("zoom", function () {
            svg.attr("transform", d3.event.transform)
        }));

    // Replace "&#39;" chars as single quote "'"
    var rawData =  "{{data.json()}}".split('&#39;').join('"');
    // Add double quotes to None elements ('None') then parse json into javascript object
    var buffers = jQuery.parseJSON(rawData.split('None').join('"None"'));
    // Get buffer names
    var bufNames = Object.keys(buffers);

    var nodes = [], links = [], graph = {};

    // For every buffer, add its producers and comsumers to nodes and create links
    for (var val of bufNames) {
        var obj = buffers[val];
        nodes.push({name: val});

        for (var stage in obj.producers) {
            nodes.push({name: stage});
            links.push({source: nodes.find(obj => obj.name === stage), target: nodes.find(obj => obj.name === val)});
        }
        if (obj.consumers !== "None") {
            for (var stage in obj.consumers) {
                nodes.push({name: stage});
                links.push({source: nodes.find(d => d.name === val), target: nodes.find(d => d.name === stage)});
            }
        }
    }

    // Remove all duplicated nodes
    graph.nodes = Array.from(new Set(nodes.map(a => a.name)))
                    .map(name => {
                        return nodes.find(a => a.name === name)
                    });
    graph.links = links;

    // Set cola parameters and enable non-overlapping
    d3cola
        .nodes(graph.nodes)
        .links(graph.links)
        .flowLayout("y", 60)
        .defaultNodeSize(100)
        .handleDisconnected(true)
        .avoidOverlaps(true)
        .start(30,20,20);

    // define arrow markers for graph links
    svg.append('svg:defs').append('svg:marker')
        .attr('id', 'end-arrow')
        .attr('viewBox', '0 -5 10 10')
        .attr('refX', 6)
        .attr('markerWidth', 3)
        .attr('markerHeight', 3)
        .attr('orient', 'auto')
        .append('svg:path')
        .attr('d', 'M0,-5L10,0L0,5')
        .attr('fill', '#000');

    // Create link objects in svg section
    var path = svg.selectAll(".link")
        .data(graph.links)
        .enter().append('line')
        .attr('class', 'link');

    // Create node objects (bounded boxes) in svg section
    var margin = 6, pad = 12, width = 60, height = 40;
    var node = svg.selectAll(".node")
        .data(graph.nodes)
        .enter().append("rect")
        .attr("class", "node")
        .attr("width", function (d) { return width + 2 * pad + 2 * margin; })
        .attr("height", function (d) { return height + 2 * pad + 2 * margin; })
        .attr("rx", 5).attr("ry", 5)
        .call(d3cola.drag);

    // Create label objects (stage and buffer names) in svg section
    var label = svg.selectAll(".label")
        .data(graph.nodes)
        .enter().append("text")
        .attr("class", "label")
        .call(d3cola.drag);

    // To avoid long string, break the label by '/'
    var insertLinebreaks = function (d) {
        var el = d3.select(this);
        var words = d.name.split('/');

        // The first line will be used to check if it is a buffer
        var tspan = el.append('tspan').text(words[0])
                        .attr('x', margin/2).attr('dy', '15')
                        .attr("font-size", "15");

        for (var i = 1; i < words.length; i++) {
            tspan = el.append('tspan').text('/' + words[i]);
            tspan.attr('x', margin/2).attr('dy', '15')
                    .attr("font-size", "15");
        }
    };
    label.each(insertLinebreaks);

    // Add names to identify different nodes
    node.append("title")
        .text(function (d) { return d.name; });

    // Add utilization for all buffers and record their index
    // Index is used later to dynamically update buffer utilization
    var index = [];
    label._groups[0].reduce((pre, cur, ind) => {
        if (bufNames.includes(cur.textContent)) {
            var el = d3.select(cur);
            tspan = el.append('tspan')
                        .text(buffers[cur.textContent].num_full_frame + "/" + buffers[cur.textContent].num_frames)
            tspan.attr('x', margin/2).attr('dy', '15')
                    .attr("font-size", "15")
                    .attr("id", "utl");
            index.push(ind)
        }
    }, 0)

    // Update utilization
    function update_utl(new_buffers){
        console.log(new_buffers);
        for (var i of index) {
            var name = d3.select(label._groups[0][i]).select("tspan").text();
            d3.select(label._groups[0][i]).select("#utl")
                .text(new_buffers[name].num_full_frame + "/" + new_buffers[name].num_frames);
        }
    }

    // Time between updating kotekan metrics
    const POLL_WAIT_TIME_MS = 1000;
    // Poll kotekan via web server every POLL_WAIT_TIME_MS and update page with new metrics
    async function poll() {
        let response = await fetch("/update");

        if (response.status == 502) {
            // Status 502 is a connection timeout error,
            // may happen when the connection was pending for too long,
            // and the remote server or a proxy closed it
            // let's reconnect
        } else if (response.status != 200) {
            // An error - let's show it
            console.log("Error: " + response.statusText);
            // Reconnect in one second
            await new Promise(resolve => setTimeout(resolve, 1000));
        } else {

            // Get and update buffer utilization
            let new_buffers = await response.json();
            update_utl(new_buffers);
        }
        // Call poll() again to get the next message
        setTimeout(() => { poll(); }, POLL_WAIT_TIME_MS);
    }
    // Start polling kotekan for metrics
    poll();

    // Calculate node, link, and label positions
    d3cola.on("tick", function () {
        node.each(function (d) {
            d.innerBounds = d.bounds.inflate(- margin);
        });

        path.each(function (d) {
            d.route = cola.makeEdgeBetween(d.source.innerBounds, d.target.innerBounds, 5);
            if (isIE())  this.parentNode.insertBefore(this, this);
        });

        path.attr("x1", function (d) { return d.route.sourceIntersection.x; })
            .attr("y1", function (d) { return d.route.sourceIntersection.y; })
            .attr("x2", function (d) { return d.route.arrowStart.x; })
            .attr("y2", function (d) { return d.route.arrowStart.y; });

        label.each(function (d) {
            var b = this.getBBox();
            d.width = b.width + 2 * margin + 8;
            d.height = b.height + 2 * margin + 8;
        });

        node.attr("x", function (d) { return d.innerBounds.x; })
            .attr("y", function (d) { return d.innerBounds.y; })
            .attr("width", function (d) { return Math.abs(d.innerBounds.width()); })
            .attr("height", function (d) { return Math.abs(d.innerBounds.height()); });

        label.attr("transform", function (d) {
            return "translate(" + d.innerBounds.x + margin + "," + (d.innerBounds.y + margin/2) + ")";
        });
    });

    function isIE() { return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') && (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null))); }
</script>
</body>
</html>
