<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8" />
<title>Downward Edges</title>
<style>
@import url(../style.css);

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  fill: none;
  stroke: #000;
  stroke-width: 1.5px;
  opacity: 0.4;
  marker-end: url(#end-arrow);
}

text {
  font-family: sans-serif;
  font-size: 15px;
  opacity: 1.0;
}


</style>
</head>
<body>
    <a href="../index.html">cola.js home</a>
<h1>Directed Graph with downward-pointing edges</h1>
<script src="{{url_for('static', filename='d3v4.js')}}"></script>
<script src="{{url_for('static', filename='cola.min.js')}}"></script>
<script type="text/javascript" src="https://canvasjs.com/assets/script/jquery-1.11.1.min.js"></script>
<script>
    var width = 960,
        height = 500;
  //var w = document.getElementById("graph").clientWidth;
  //var h = document.getElementById("graph").clientHeight;

    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var d3cola = cola.d3adaptor(d3)
        //.handleDisconnected(false)
        //.linkDistance(300)
        //.groupCompactness(100)
        .size([width, height]);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    // Replace "&#39;" chars as single quote "'"
    var rawData =  "{{data.json()}}".split('&#39;').join('"');
    // Add double quotes to None elements ('None') then parse json into javascript object
    var buffers = jQuery.parseJSON(rawData.split('None').join('"None"'));
    // Get buffer names
    var bufNames = Object.keys(buffers);
        
    console.log(bufNames);

    d3.json("{{url_for('static', filename='chris.json')}}", function (error, graph) {
        var nodeRadius = 8;

        var nodes = [], links = [];
       
        var buf_ctr = 0;
        for (var val in buffers) {
          nodes.push({name: val});
          for (var stage in buffers[val].producers) {
              nodes.push({name: stage});
              links.push({source: nodes[nodes.length - 1], target: nodes[buf_ctr]});
          }

          for (var stage in buffers[val].consumers) {
              nodes.push({name: stage});
              links.push({source: nodes[buf_ctr], target: nodes[nodes.length - 1]});
          }
          buf_ctr++;
        }
 
        graph.nodes = nodes;
        graph.links = links;
        
        // Set node size larger to space graph out
        graph.nodes.forEach(function (v) { v.height = v.width = 5 * nodeRadius; });

        console.log(graph.nodes)
        console.log(graph.links)

        d3cola
            .nodes(graph.nodes)
            .links(graph.links)
            .flowLayout("y", 65)
            //.symmetricDiffLinkLengths(6)
            //.convergenceThreshold(1e-9)
            //.defaultNodeSize(100)
            .handleDisconnected(true)
            .avoidOverlaps(true)
            .start(30,20,20);

        // define arrow markers for graph links
        svg.append('svg:defs').append('svg:marker')
            .attr('id', 'end-arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 6)
            .attr('markerWidth', 3)
            .attr('markerHeight', 3)
            .attr('orient', 'auto')
            .append('svg:path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#000');

        var path = svg.selectAll(".link")
            .data(graph.links)
            .enter().append('svg:path')
            .attr('class', 'link');

        var node = svg.selectAll("circle.node")
            .data(graph.nodes)
            .enter().append("g")
            .attr("class", "node");
      
        node.append("circle")
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
            .attr("r", nodeRadius)
            .style("fill", function (d) { return color(d.group); })
            //.call(d3cola.drag);

        // Draw labels
        //node.append("text")
        //   .text(function(d, i) { return d.name; })
        //   .attr("x",            function(d, i) { return d.x + nodeRadius; })
        //   .attr("y",            function(d, i) { return d.y + nodeRadius})
        //   .attr("font-family",  "Bree Serif")
        //   .attr("fill",         function(d, i) {  return  "#2176C7";  })
        //   .attr("font-size",    function(d, i) {  return  "1em"; })
        //   .attr("text-anchor", "middle")

        node.append("text")
            .attr("class", "labels")
            .text(function (d) { return d.name; })
            .attr("x", function(d, i) { return d.x + 1.2*nodeRadius; })
            .attr("y", function(d, i) { return d.y + nodeRadius; })
            //.attr("font-family",  "Bree Serif")
            .attr("font-weight", 900)
            .attr("fill",   "black")

        d3cola.on("tick", function () {
            path.each(function (d) {
                if (isIE()) this.parentNode.insertBefore(this, this);
            });
            // draw directed edges with proper padding from node centers
            path.attr('d', function (d) {
                var deltaX = d.target.x - d.source.x,
                    deltaY = d.target.y - d.source.y,
                    dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
                    normX = deltaX / dist,
                    normY = deltaY / dist,
                    sourcePadding = nodeRadius,
                    targetPadding = nodeRadius + 2,
                    sourceX = d.source.x + (sourcePadding * normX),
                    sourceY = d.source.y + (sourcePadding * normY),
                    targetX = d.target.x - (targetPadding * normX),
                    targetY = d.target.y - (targetPadding * normY);
                return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
            });

            node.attr("cx", function (d) { return d.x; })
                .attr("cy", function (d) { return d.y; });
        });
        // turn on overlap avoidance after first convergence
        //cola.on("end", function () {
        //    if (!cola.avoidOverlaps()) {
        //        graph.nodes.forEach(function (v) {
        //            v.width = v.height = 10;
        //        });
        //        cola.avoidOverlaps(true);
        //        cola.start();
        //    }
        //});
    });

    function isIE() { return ((navigator.appName == 'Microsoft Internet Explorer') || ((navigator.appName == 'Netscape') && (new RegExp("Trident/.*rv:([0-9]{1,}[\.0-9]{0,})").exec(navigator.userAgent) != null))); }
</script>

<!--p>Pairs of nodes connected by an edge have a vertical separation constraint, requiring that the source be a minimum distance above the target.
   We also require that node bounding boxes cannot overlap.
     The unconstrained layout of the same graph looks like <a href="unconstrained.html">this</a>.
    </p-->
    <!--p>Here's <a href="3dtree.html">a 3D version</a> of the same graph!</p-->
<!--script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63535113-1', 'auto');
  ga('send', 'pageview');

</script-->
</body>
</html>
